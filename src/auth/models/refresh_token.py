"""
RefreshToken Model Implementation for Auth0 Refresh Token Management.

This module implements the RefreshToken model using Flask-SQLAlchemy declarative patterns with
comprehensive Auth0 refresh token lifecycle management, automated rotation policies, and security
revocation capabilities. The model integrates with Auth0's refresh token rotation policy and
Flask-JWT-Extended for enhanced security posture and automated threat detection.

Key Features:
- Auth0 refresh token lifecycle management with automated rotation per Section 6.4.1.4
- Token family tracking for suspicious activity detection and automated revocation
- Immediate token revocation capabilities for security incidents per Section 6.4.6.2
- Integration with Flask-JWT-Extended 4.7.1 for local JWT processing and validation
- Token blacklist management with automated revocation hooks and grace period handling
- PostgreSQL-optimized field types and indexes for performance and security monitoring
- Automated token cleanup and rotation scheduling for enhanced security compliance
- Comprehensive audit logging integration for security incident tracking and analysis
- Real-time security metrics collection via Prometheus for monitoring and alerting

Security Architecture:
- Auth0 Python SDK 4.9.0 integration for enterprise identity management
- Automated token rotation implementing Auth0's security best practices
- Token family detection for credential stuffing and replay attack prevention
- Immediate invalidation capabilities for security incident response
- Grace period management for seamless user experience during rotation
- Comprehensive revocation flow management with blocklist synchronization

Technical Specification References:
- Section 6.4.1.4: Token Handling with Flask-JWT-Extended Integration
- Section 6.4.1.4: Auth0 Refresh Token Rotation Policy Implementation
- Section 6.4.6.2: Incident Response Procedures with Token Revocation
- Section 6.4.2.5: Audit Logging for Security Compliance and Monitoring
- Section 6.2.1: Database Technology Transition to PostgreSQL 15.x
- Feature F-007: Authentication Mechanism Migration with Zero Security Degradation
"""

import secrets
import hashlib
import uuid
from datetime import datetime, timezone, timedelta
from typing import Optional, List, Dict, Any, Union
from enum import Enum
from dataclasses import dataclass

from flask import current_app
from sqlalchemy import (
    Column, Integer, String, Text, Boolean, DateTime, ForeignKey,
    Index, CheckConstraint, event, text, func
)
from sqlalchemy.orm import relationship, validates
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.dialects.postgresql import UUID, JSONB

# Import base model for inheritance pattern consistency
from ...models.base import BaseModel, db


class TokenStatus(Enum):
    """
    Enumeration for refresh token status tracking with comprehensive lifecycle management.
    
    Token status values provide granular tracking of refresh token states throughout
    their lifecycle for security monitoring, automated rotation, and incident response.
    
    Values:
        ACTIVE: Token is currently valid and can be used for refresh operations
        EXPIRED: Token has exceeded its lifetime and is no longer valid for refresh
        REVOKED: Token has been explicitly revoked due to security concerns or logout
        BLACKLISTED: Token has been added to blacklist for immediate invalidation
        ROTATED: Token has been replaced by a new token during rotation process
        SUSPENDED: Token is temporarily suspended pending security investigation
        COMPROMISED: Token has been identified as potentially compromised
        FAMILY_REVOKED: Token family has been revoked due to suspicious activity
    """
    ACTIVE = "active"
    EXPIRED = "expired"
    REVOKED = "revoked"
    BLACKLISTED = "blacklisted"
    ROTATED = "rotated"
    SUSPENDED = "suspended"
    COMPROMISED = "compromised"
    FAMILY_REVOKED = "family_revoked"


class TokenSource(Enum):
    """
    Enumeration for token source tracking and security analysis.
    
    Token source identification enables security monitoring and analysis
    of token generation patterns for threat detection and audit compliance.
    
    Values:
        AUTH0_LOGIN: Token generated during Auth0 authentication flow
        AUTH0_REFRESH: Token generated during Auth0 refresh token rotation
        FLASK_LOCAL: Token generated by Flask-JWT-Extended local processing
        SYSTEM_ADMIN: Token generated by system administrator for testing
        MIGRATION: Token generated during Node.js to Flask migration process
        EMERGENCY: Token generated during emergency access procedures
    """
    AUTH0_LOGIN = "auth0_login"
    AUTH0_REFRESH = "auth0_refresh"
    FLASK_LOCAL = "flask_local"
    SYSTEM_ADMIN = "system_admin"
    MIGRATION = "migration"
    EMERGENCY = "emergency"


@dataclass
class TokenMetadata:
    """
    Data class for refresh token metadata and security context.
    
    Provides structured storage for token-related metadata including
    security context, rotation history, and threat detection information.
    
    Attributes:
        client_id (str): Auth0 client identifier for application context
        device_fingerprint (str): Device fingerprint for security tracking
        ip_address (str): IP address where token was generated or last used
        user_agent (str): User agent string for client identification
        rotation_count (int): Number of times token has been rotated
        last_used_at (datetime): Timestamp of last token usage
        security_flags (List[str]): Security flags for threat detection
        auth0_token_id (str): Auth0 internal token identifier
        family_size (int): Number of tokens in the same family
    """
    client_id: Optional[str] = None
    device_fingerprint: Optional[str] = None
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    rotation_count: int = 0
    last_used_at: Optional[datetime] = None
    security_flags: List[str] = None
    auth0_token_id: Optional[str] = None
    family_size: int = 1
    
    def __post_init__(self):
        if self.security_flags is None:
            self.security_flags = []


class RefreshToken(BaseModel):
    """
    RefreshToken model implementing Auth0 refresh token management with automated rotation.
    
    This model provides comprehensive refresh token lifecycle management with Auth0 integration,
    automated rotation policies, and security revocation capabilities. Critical for maintaining
    secure authentication flows while enabling seamless user experience through token rotation.
    
    The model implements Auth0's refresh token rotation policy with automated revocation hooks,
    token family tracking for suspicious activity detection, and immediate invalidation
    capabilities for security incident response per Section 6.4.6.2.
    
    Inherits from BaseModel for common functionality:
    - Auto-incrementing primary key (id)
    - Automatic timestamp management (created_at, updated_at)
    - Common utility methods for serialization and persistence
    - PostgreSQL-optimized field patterns and indexing strategy
    
    Attributes:
        id (int): Primary key inherited from BaseModel for optimal join performance
        user_id (int): Foreign key to User model for token ownership tracking
        token_hash (str): SHA-256 hash of the refresh token for secure storage
        token_family (str): UUID identifying token family for rotation tracking
        auth0_token_id (str): Auth0 internal token identifier for API integration
        status (TokenStatus): Current token status for lifecycle management
        source (TokenSource): Token generation source for security analysis
        expires_at (datetime): Token expiration timestamp for automated cleanup
        last_used_at (datetime): Last usage timestamp for activity monitoring
        revoked_at (datetime): Revocation timestamp for audit trail
        revoked_by_user_id (int): User who initiated revocation for accountability
        revocation_reason (str): Reason for token revocation for security analysis
        rotation_parent_id (int): Parent token ID for rotation chain tracking
        metadata (dict): JSON metadata for security context and device tracking
        security_score (float): Calculated security score for threat assessment
        is_blacklisted (bool): Immediate blacklist flag for emergency revocation
        grace_period_expires (datetime): Grace period expiration for rotation overlap
        auth0_refresh_count (int): Number of Auth0 refresh operations performed
        suspicious_activity_count (int): Count of suspicious activities detected
        created_at (datetime): Timestamp inherited from BaseModel
        updated_at (datetime): Timestamp inherited from BaseModel
        
    Relationships:
        user (User): Many-to-one relationship with User model for token ownership
        rotation_parent (RefreshToken): Self-referential relationship for rotation chains
        rotation_children (List[RefreshToken]): Tokens generated from this token
        security_incidents (List[SecurityIncident]): Related security incidents
    """
    
    __tablename__ = 'refresh_tokens'
    
    # User relationship for token ownership per Section 6.4.1.4
    user_id = Column(
        Integer,
        ForeignKey('users.id', ondelete='CASCADE'),
        nullable=False,
        index=True,
        comment="Foreign key to User model for token ownership tracking"
    )
    
    # Token storage and identification fields with security hashing
    token_hash = Column(
        String(64),  # SHA-256 hash length
        nullable=False,
        unique=True,
        index=True,
        comment="SHA-256 hash of the refresh token for secure storage"
    )
    
    token_family = Column(
        UUID(as_uuid=True),
        nullable=False,
        default=uuid.uuid4,
        index=True,
        comment="UUID identifying token family for rotation tracking"
    )
    
    auth0_token_id = Column(
        String(128),
        nullable=True,
        index=True,
        comment="Auth0 internal token identifier for API integration"
    )
    
    # Token lifecycle and status management per Section 6.4.1.4
    status = Column(
        String(20),
        nullable=False,
        default=TokenStatus.ACTIVE.value,
        index=True,
        comment="Current token status for lifecycle management"
    )
    
    source = Column(
        String(20),
        nullable=False,
        default=TokenSource.AUTH0_LOGIN.value,
        index=True,
        comment="Token generation source for security analysis"
    )
    
    # Timestamp fields for token lifecycle management
    expires_at = Column(
        DateTime(timezone=True),
        nullable=False,
        index=True,
        comment="Token expiration timestamp for automated cleanup"
    )
    
    last_used_at = Column(
        DateTime(timezone=True),
        nullable=True,
        index=True,
        comment="Last usage timestamp for activity monitoring"
    )
    
    revoked_at = Column(
        DateTime(timezone=True),
        nullable=True,
        index=True,
        comment="Revocation timestamp for audit trail"
    )
    
    revoked_by_user_id = Column(
        Integer,
        ForeignKey('users.id', ondelete='SET NULL'),
        nullable=True,
        comment="User who initiated revocation for accountability"
    )
    
    revocation_reason = Column(
        Text,
        nullable=True,
        comment="Reason for token revocation for security analysis"
    )
    
    # Token rotation chain tracking per Auth0 rotation policy
    rotation_parent_id = Column(
        Integer,
        ForeignKey('refresh_tokens.id', ondelete='SET NULL'),
        nullable=True,
        index=True,
        comment="Parent token ID for rotation chain tracking"
    )
    
    # Security and metadata fields for threat detection
    metadata = Column(
        JSONB,
        nullable=False,
        default=dict,
        comment="JSON metadata for security context and device tracking"
    )
    
    security_score = Column(
        Integer,
        nullable=False,
        default=0,
        comment="Calculated security score for threat assessment (0-100)"
    )
    
    is_blacklisted = Column(
        Boolean,
        nullable=False,
        default=False,
        index=True,
        comment="Immediate blacklist flag for emergency revocation"
    )
    
    # Grace period management for rotation overlap per Section 6.4.1.4
    grace_period_expires = Column(
        DateTime(timezone=True),
        nullable=True,
        index=True,
        comment="Grace period expiration for rotation overlap"
    )
    
    # Auth0 integration and activity tracking
    auth0_refresh_count = Column(
        Integer,
        nullable=False,
        default=0,
        comment="Number of Auth0 refresh operations performed"
    )
    
    suspicious_activity_count = Column(
        Integer,
        nullable=False,
        default=0,
        comment="Count of suspicious activities detected"
    )
    
    # Relationship mapping per Section 6.2.2.1
    user = relationship(
        'User',
        foreign_keys=[user_id],
        back_populates='refresh_tokens',
        lazy='select',
        doc="Many-to-one relationship with User model for token ownership"
    )
    
    revoked_by_user = relationship(
        'User',
        foreign_keys=[revoked_by_user_id],
        lazy='select',
        doc="User who initiated token revocation for audit trail"
    )
    
    # Self-referential relationship for rotation chain tracking
    rotation_parent = relationship(
        'RefreshToken',
        remote_side='RefreshToken.id',
        foreign_keys=[rotation_parent_id],
        back_populates='rotation_children',
        lazy='select',
        doc="Parent token in rotation chain for tracking hierarchy"
    )
    
    rotation_children = relationship(
        'RefreshToken',
        remote_side='RefreshToken.rotation_parent_id',
        back_populates='rotation_parent',
        lazy='dynamic',
        cascade='all, delete-orphan',
        passive_deletes=True,
        doc="Child tokens generated from this token during rotation"
    )
    
    # Database constraints and indexes per Section 6.2.2.2
    __table_args__ = (
        # Check constraints for data validation and security
        CheckConstraint(
            f"status IN ('{TokenStatus.ACTIVE.value}', '{TokenStatus.EXPIRED.value}', "
            f"'{TokenStatus.REVOKED.value}', '{TokenStatus.BLACKLISTED.value}', "
            f"'{TokenStatus.ROTATED.value}', '{TokenStatus.SUSPENDED.value}', "
            f"'{TokenStatus.COMPROMISED.value}', '{TokenStatus.FAMILY_REVOKED.value}')",
            name='ck_refresh_token_status_valid'
        ),
        CheckConstraint(
            f"source IN ('{TokenSource.AUTH0_LOGIN.value}', '{TokenSource.AUTH0_REFRESH.value}', "
            f"'{TokenSource.FLASK_LOCAL.value}', '{TokenSource.SYSTEM_ADMIN.value}', "
            f"'{TokenSource.MIGRATION.value}', '{TokenSource.EMERGENCY.value}')",
            name='ck_refresh_token_source_valid'
        ),
        CheckConstraint('security_score >= 0 AND security_score <= 100', name='ck_refresh_token_security_score_range'),
        CheckConstraint('auth0_refresh_count >= 0', name='ck_refresh_token_refresh_count_positive'),
        CheckConstraint('suspicious_activity_count >= 0', name='ck_refresh_token_suspicious_count_positive'),
        CheckConstraint('expires_at > created_at', name='ck_refresh_token_expires_after_created'),
        
        # Composite indexes for performance optimization per Section 6.2.2.2
        Index('ix_refresh_token_user_status', 'user_id', 'status'),
        Index('ix_refresh_token_user_active', 'user_id', 'status', postgresql_where=(
            text(f"status = '{TokenStatus.ACTIVE.value}'")
        )),
        Index('ix_refresh_token_family_status', 'token_family', 'status'),
        Index('ix_refresh_token_expires_status', 'expires_at', 'status'),
        Index('ix_refresh_token_blacklist_status', 'is_blacklisted', 'status'),
        Index('ix_refresh_token_security_score', 'security_score', 'status'),
        Index('ix_refresh_token_suspicious_activity', 'suspicious_activity_count', 'user_id'),
        Index('ix_refresh_token_grace_period', 'grace_period_expires', 'status'),
        Index('ix_refresh_token_last_used', 'last_used_at', 'user_id'),
        Index('ix_refresh_token_rotation_chain', 'rotation_parent_id', 'token_family'),
        Index('ix_refresh_token_auth0_integration', 'auth0_token_id', 'status'),
        
        # Partial indexes for active tokens performance
        Index('ix_refresh_token_active_expires', 'expires_at', postgresql_where=(
            text(f"status = '{TokenStatus.ACTIVE.value}' AND is_blacklisted = false")
        )),
        Index('ix_refresh_token_active_family', 'token_family', 'user_id', postgresql_where=(
            text(f"status = '{TokenStatus.ACTIVE.value}'")
        )),
        
        # Table-level comment for documentation
        {'comment': 'Refresh tokens with Auth0 integration and automated rotation policies'}
    )
    
    def __init__(
        self,
        user_id: int,
        token_value: str,
        expires_at: datetime,
        token_family: Optional[str] = None,
        auth0_token_id: Optional[str] = None,
        source: TokenSource = TokenSource.AUTH0_LOGIN,
        metadata: Optional[Dict[str, Any]] = None,
        rotation_parent_id: Optional[int] = None,
        **kwargs
    ) -> None:
        """
        Initialize a new RefreshToken instance with validation and security setup.
        
        Args:
            user_id (int): User ID for token ownership
            token_value (str): Raw refresh token value for hashing
            expires_at (datetime): Token expiration timestamp
            token_family (Optional[str]): Token family UUID (generated if not provided)
            auth0_token_id (Optional[str]): Auth0 internal token identifier
            source (TokenSource): Token generation source (default: AUTH0_LOGIN)
            metadata (Optional[Dict]): Security metadata and device context
            rotation_parent_id (Optional[int]): Parent token for rotation chain
            **kwargs: Additional keyword arguments for model fields
            
        Raises:
            ValueError: If token value or user_id validation fails
            SecurityError: If token security validation fails
        """
        super().__init__(**kwargs)
        
        # Validate required fields
        if not user_id:
            raise ValueError("User ID is required for token ownership")
        
        if not token_value:
            raise ValueError("Token value is required for hashing")
        
        if not expires_at:
            raise ValueError("Expiration timestamp is required")
        
        # Set basic fields
        self.user_id = user_id
        self.token_hash = self._hash_token(token_value)
        self.expires_at = expires_at
        self.auth0_token_id = auth0_token_id
        self.source = source.value if isinstance(source, TokenSource) else source
        self.rotation_parent_id = rotation_parent_id
        
        # Set token family (inherit from parent or generate new)
        if token_family:
            self.token_family = uuid.UUID(token_family) if isinstance(token_family, str) else token_family
        elif rotation_parent_id:
            # Inherit family from parent token
            parent_token = RefreshToken.query.get(rotation_parent_id)
            if parent_token:
                self.token_family = parent_token.token_family
            else:
                self.token_family = uuid.uuid4()
        else:
            self.token_family = uuid.uuid4()
        
        # Initialize status and security fields
        self.status = TokenStatus.ACTIVE.value
        self.is_blacklisted = False
        self.security_score = self._calculate_initial_security_score(metadata or {})
        self.auth0_refresh_count = 0
        self.suspicious_activity_count = 0
        
        # Set metadata with security context
        self.metadata = self._prepare_metadata(metadata or {})
        
        # Initialize timestamps
        self.last_used_at = None
        self.revoked_at = None
        self.revoked_by_user_id = None
        self.revocation_reason = None
        
        # Set grace period for rotation overlap
        self.grace_period_expires = self._calculate_grace_period()
    
    @staticmethod
    def _hash_token(token_value: str) -> str:
        """
        Generate SHA-256 hash of refresh token for secure storage.
        
        Args:
            token_value (str): Raw token value to hash
            
        Returns:
            str: SHA-256 hash of the token value
        """
        if not token_value:
            raise ValueError("Token value cannot be empty")
        
        return hashlib.sha256(token_value.encode('utf-8')).hexdigest()
    
    def _calculate_initial_security_score(self, metadata: Dict[str, Any]) -> int:
        """
        Calculate initial security score based on token metadata.
        
        Args:
            metadata (Dict): Token metadata for score calculation
            
        Returns:
            int: Security score from 0-100
        """
        score = 50  # Base score
        
        # Increase score for known device fingerprints
        if metadata.get('device_fingerprint'):
            score += 10
        
        # Increase score for Auth0 login source
        if self.source == TokenSource.AUTH0_LOGIN.value:
            score += 15
        
        # Decrease score for suspicious IP patterns
        ip_address = metadata.get('ip_address')
        if ip_address and self._is_suspicious_ip(ip_address):
            score -= 20
        
        # Decrease score for unknown user agents
        user_agent = metadata.get('user_agent')
        if user_agent and self._is_suspicious_user_agent(user_agent):
            score -= 15
        
        return max(0, min(100, score))
    
    def _is_suspicious_ip(self, ip_address: str) -> bool:
        """
        Check if IP address is suspicious based on threat intelligence.
        
        Args:
            ip_address (str): IP address to check
            
        Returns:
            bool: True if IP is suspicious
        """
        # Basic suspicious IP detection (would integrate with threat intelligence)
        suspicious_patterns = [
            '192.168.',  # Private networks (suspicious for external tokens)
            '10.',       # Private networks
            '172.16.',   # Private networks
            '127.',      # Localhost
        ]
        
        # Check for known suspicious patterns
        for pattern in suspicious_patterns:
            if ip_address.startswith(pattern):
                return True
        
        return False
    
    def _is_suspicious_user_agent(self, user_agent: str) -> bool:
        """
        Check if user agent is suspicious based on patterns.
        
        Args:
            user_agent (str): User agent string to check
            
        Returns:
            bool: True if user agent is suspicious
        """
        if not user_agent:
            return True
        
        # Check for bot patterns
        bot_patterns = ['bot', 'crawler', 'spider', 'scraper', 'curl', 'wget']
        user_agent_lower = user_agent.lower()
        
        for pattern in bot_patterns:
            if pattern in user_agent_lower:
                return True
        
        return False
    
    def _prepare_metadata(self, metadata: Dict[str, Any]) -> Dict[str, Any]:
        """
        Prepare and validate metadata for token storage.
        
        Args:
            metadata (Dict): Raw metadata to prepare
            
        Returns:
            Dict: Prepared metadata with security context
        """
        prepared = metadata.copy()
        
        # Add creation context
        prepared['created_by'] = 'flask_refresh_token_model'
        prepared['creation_timestamp'] = datetime.now(timezone.utc).isoformat()
        
        # Add security flags
        if 'security_flags' not in prepared:
            prepared['security_flags'] = []
        
        # Add rotation context if applicable
        if self.rotation_parent_id:
            prepared['is_rotation'] = True
            prepared['rotation_generation'] = self._get_rotation_generation()
        else:
            prepared['is_rotation'] = False
            prepared['rotation_generation'] = 0
        
        return prepared
    
    def _get_rotation_generation(self) -> int:
        """
        Calculate rotation generation for tracking token chain depth.
        
        Returns:
            int: Generation number in rotation chain
        """
        if not self.rotation_parent_id:
            return 0
        
        parent_token = RefreshToken.query.get(self.rotation_parent_id)
        if parent_token and 'rotation_generation' in parent_token.metadata:
            return parent_token.metadata['rotation_generation'] + 1
        
        return 1
    
    def _calculate_grace_period(self) -> Optional[datetime]:
        """
        Calculate grace period expiration for rotation overlap.
        
        Returns:
            Optional[datetime]: Grace period expiration or None
        """
        grace_period_seconds = current_app.config.get('REFRESH_TOKEN_GRACE_PERIOD_SECONDS', 30)
        
        if self.rotation_parent_id and grace_period_seconds > 0:
            return datetime.now(timezone.utc) + timedelta(seconds=grace_period_seconds)
        
        return None
    
    @validates('status')
    def validate_status(self, key: str, value: str) -> str:
        """
        SQLAlchemy validator for token status field.
        
        Args:
            key (str): Field name being validated
            value (str): Status value being set
            
        Returns:
            str: Validated status value
        """
        valid_statuses = [status.value for status in TokenStatus]
        if value not in valid_statuses:
            raise ValueError(f"Invalid token status: {value}")
        
        return value
    
    @validates('source')
    def validate_source(self, key: str, value: str) -> str:
        """
        SQLAlchemy validator for token source field.
        
        Args:
            key (str): Field name being validated
            value (str): Source value being set
            
        Returns:
            str: Validated source value
        """
        valid_sources = [source.value for source in TokenSource]
        if value not in valid_sources:
            raise ValueError(f"Invalid token source: {value}")
        
        return value
    
    def verify_token(self, token_value: str) -> bool:
        """
        Verify provided token value against stored hash.
        
        Args:
            token_value (str): Raw token value to verify
            
        Returns:
            bool: True if token matches stored hash
        """
        if not token_value:
            return False
        
        return self.token_hash == self._hash_token(token_value)
    
    def is_valid(self) -> bool:
        """
        Check if token is currently valid for use.
        
        Returns:
            bool: True if token is valid and usable
        """
        current_time = datetime.now(timezone.utc)
        
        # Check basic validity conditions
        if self.status != TokenStatus.ACTIVE.value:
            return False
        
        if self.is_blacklisted:
            return False
        
        if current_time >= self.expires_at:
            return False
        
        # Check grace period for rotated tokens
        if self.grace_period_expires and current_time >= self.grace_period_expires:
            return False
        
        return True
    
    def is_expired(self) -> bool:
        """
        Check if token has expired based on expiration timestamp.
        
        Returns:
            bool: True if token has expired
        """
        return datetime.now(timezone.utc) >= self.expires_at
    
    def is_in_grace_period(self) -> bool:
        """
        Check if token is within grace period for rotation overlap.
        
        Returns:
            bool: True if token is in grace period
        """
        if not self.grace_period_expires:
            return False
        
        return datetime.now(timezone.utc) < self.grace_period_expires
    
    def update_last_used(self, ip_address: Optional[str] = None, user_agent: Optional[str] = None) -> None:
        """
        Update last used timestamp and metadata for activity tracking.
        
        Args:
            ip_address (Optional[str]): IP address for security tracking
            user_agent (Optional[str]): User agent for device tracking
        """
        self.last_used_at = datetime.now(timezone.utc)
        
        # Update metadata with usage context
        if ip_address:
            self.metadata['last_used_ip'] = ip_address
        
        if user_agent:
            self.metadata['last_used_user_agent'] = user_agent
        
        # Update security score based on usage patterns
        self._update_security_score_on_usage(ip_address, user_agent)
        
        self.updated_at = datetime.now(timezone.utc)
    
    def _update_security_score_on_usage(self, ip_address: Optional[str], user_agent: Optional[str]) -> None:
        """
        Update security score based on usage patterns.
        
        Args:
            ip_address (Optional[str]): IP address for analysis
            user_agent (Optional[str]): User agent for analysis
        """
        score_change = 0
        
        # Check for IP address consistency
        if ip_address:
            original_ip = self.metadata.get('ip_address')
            if original_ip and original_ip != ip_address:
                # Different IP - potential security concern
                score_change -= 5
                self._flag_suspicious_activity('ip_address_change')
            
            # Check for suspicious IP
            if self._is_suspicious_ip(ip_address):
                score_change -= 10
                self._flag_suspicious_activity('suspicious_ip_usage')
        
        # Check for user agent consistency
        if user_agent:
            original_ua = self.metadata.get('user_agent')
            if original_ua and original_ua != user_agent:
                # Different user agent - potential security concern
                score_change -= 3
                self._flag_suspicious_activity('user_agent_change')
        
        # Apply score change
        new_score = max(0, min(100, self.security_score + score_change))
        self.security_score = new_score
        
        # Auto-blacklist if score drops too low
        if new_score <= 10:
            self._auto_blacklist('low_security_score')
    
    def _flag_suspicious_activity(self, activity_type: str) -> None:
        """
        Flag suspicious activity for security monitoring.
        
        Args:
            activity_type (str): Type of suspicious activity detected
        """
        self.suspicious_activity_count += 1
        
        # Add to security flags
        if 'security_flags' not in self.metadata:
            self.metadata['security_flags'] = []
        
        self.metadata['security_flags'].append({
            'type': activity_type,
            'timestamp': datetime.now(timezone.utc).isoformat(),
            'count': self.suspicious_activity_count
        })
        
        # Auto-revoke if too many suspicious activities
        if self.suspicious_activity_count >= 3:
            self.revoke_token(
                reason=f"Automatic revocation due to suspicious activity: {activity_type}",
                revoked_by_user_id=None
            )
    
    def _auto_blacklist(self, reason: str) -> None:
        """
        Automatically blacklist token for security reasons.
        
        Args:
            reason (str): Reason for automatic blacklisting
        """
        self.is_blacklisted = True
        self.status = TokenStatus.BLACKLISTED.value
        self.revocation_reason = f"Auto-blacklisted: {reason}"
        self.revoked_at = datetime.now(timezone.utc)
        self.updated_at = datetime.now(timezone.utc)
        
        # Log security event
        from .security_incident import SecurityIncident, IncidentType, IncidentSeverity
        SecurityIncident.create_incident(
            incident_type=IncidentType.TOKEN_BLACKLIST,
            severity=IncidentSeverity.MEDIUM,
            user_id=self.user_id,
            description=f"Refresh token auto-blacklisted: {reason}",
            metadata={'token_id': self.id, 'reason': reason}
        )
    
    def revoke_token(
        self,
        reason: str,
        revoked_by_user_id: Optional[int] = None,
        revoke_family: bool = False
    ) -> bool:
        """
        Revoke refresh token with audit trail and optional family revocation.
        
        Args:
            reason (str): Reason for token revocation
            revoked_by_user_id (Optional[int]): User ID who initiated revocation
            revoke_family (bool): Whether to revoke entire token family
            
        Returns:
            bool: True if revocation successful
        """
        if self.status in [TokenStatus.REVOKED.value, TokenStatus.BLACKLISTED.value]:
            return False  # Already revoked
        
        # Update token status
        self.status = TokenStatus.REVOKED.value
        self.revoked_at = datetime.now(timezone.utc)
        self.revoked_by_user_id = revoked_by_user_id
        self.revocation_reason = reason
        self.updated_at = datetime.now(timezone.utc)
        
        # Revoke family if requested
        if revoke_family:
            self._revoke_token_family(reason, revoked_by_user_id)
        
        # Create security incident for revocation
        from .security_incident import SecurityIncident, IncidentType, IncidentSeverity
        SecurityIncident.create_incident(
            incident_type=IncidentType.TOKEN_REVOCATION,
            severity=IncidentSeverity.MEDIUM,
            user_id=self.user_id,
            description=f"Refresh token revoked: {reason}",
            metadata={
                'token_id': self.id,
                'reason': reason,
                'revoked_by_user_id': revoked_by_user_id,
                'family_revoked': revoke_family
            }
        )
        
        return True
    
    def _revoke_token_family(self, reason: str, revoked_by_user_id: Optional[int]) -> int:
        """
        Revoke entire token family for security incidents.
        
        Args:
            reason (str): Reason for family revocation
            revoked_by_user_id (Optional[int]): User who initiated revocation
            
        Returns:
            int: Number of tokens revoked in family
        """
        family_tokens = RefreshToken.query.filter(
            RefreshToken.token_family == self.token_family,
            RefreshToken.status.in_([TokenStatus.ACTIVE.value, TokenStatus.SUSPENDED.value])
        ).all()
        
        revoked_count = 0
        for token in family_tokens:
            if token.id != self.id:  # Don't re-revoke current token
                token.status = TokenStatus.FAMILY_REVOKED.value
                token.revoked_at = datetime.now(timezone.utc)
                token.revoked_by_user_id = revoked_by_user_id
                token.revocation_reason = f"Family revocation: {reason}"
                token.updated_at = datetime.now(timezone.utc)
                revoked_count += 1
        
        return revoked_count
    
    def rotate_token(
        self,
        new_token_value: str,
        new_expires_at: datetime,
        metadata: Optional[Dict[str, Any]] = None
    ) -> 'RefreshToken':
        """
        Rotate refresh token implementing Auth0 rotation policy.
        
        Args:
            new_token_value (str): New token value for rotation
            new_expires_at (datetime): New token expiration
            metadata (Optional[Dict]): Additional metadata for new token
            
        Returns:
            RefreshToken: New token created during rotation
        """
        # Mark current token as rotated
        self.status = TokenStatus.ROTATED.value
        self.updated_at = datetime.now(timezone.utc)
        
        # Prepare metadata for new token
        new_metadata = (metadata or {}).copy()
        new_metadata.update({
            'rotation_source_token_id': self.id,
            'rotation_timestamp': datetime.now(timezone.utc).isoformat(),
            'rotation_reason': 'standard_rotation'
        })
        
        # Inherit security context from parent
        if 'device_fingerprint' in self.metadata:
            new_metadata['device_fingerprint'] = self.metadata['device_fingerprint']
        
        if 'client_id' in self.metadata:
            new_metadata['client_id'] = self.metadata['client_id']
        
        # Create new token in same family
        new_token = RefreshToken(
            user_id=self.user_id,
            token_value=new_token_value,
            expires_at=new_expires_at,
            token_family=str(self.token_family),
            source=TokenSource.AUTH0_REFRESH,
            metadata=new_metadata,
            rotation_parent_id=self.id
        )
        
        # Inherit Auth0 context
        if self.auth0_token_id:
            new_token.auth0_refresh_count = self.auth0_refresh_count + 1
        
        # Save new token
        new_token.save()
        
        return new_token
    
    def extend_expiration(self, additional_hours: int = 24) -> bool:
        """
        Extend token expiration for emergency or administrative purposes.
        
        Args:
            additional_hours (int): Hours to add to current expiration
            
        Returns:
            bool: True if extension successful
        """
        if self.status != TokenStatus.ACTIVE.value:
            return False
        
        if self.is_blacklisted:
            return False
        
        # Extend expiration
        self.expires_at = self.expires_at + timedelta(hours=additional_hours)
        self.updated_at = datetime.now(timezone.utc)
        
        # Log extension event
        self.metadata['extensions'] = self.metadata.get('extensions', [])
        self.metadata['extensions'].append({
            'timestamp': datetime.now(timezone.utc).isoformat(),
            'additional_hours': additional_hours,
            'new_expires_at': self.expires_at.isoformat()
        })
        
        return True
    
    def suspend_token(self, reason: str, suspended_by_user_id: Optional[int] = None) -> bool:
        """
        Temporarily suspend token for security investigation.
        
        Args:
            reason (str): Reason for suspension
            suspended_by_user_id (Optional[int]): User who initiated suspension
            
        Returns:
            bool: True if suspension successful
        """
        if self.status != TokenStatus.ACTIVE.value:
            return False
        
        self.status = TokenStatus.SUSPENDED.value
        self.revocation_reason = f"Suspended: {reason}"
        self.revoked_by_user_id = suspended_by_user_id
        self.updated_at = datetime.now(timezone.utc)
        
        # Add suspension metadata
        self.metadata['suspension'] = {
            'timestamp': datetime.now(timezone.utc).isoformat(),
            'reason': reason,
            'suspended_by_user_id': suspended_by_user_id
        }
        
        return True
    
    def reactivate_token(self, reactivated_by_user_id: Optional[int] = None) -> bool:
        """
        Reactivate suspended token after investigation.
        
        Args:
            reactivated_by_user_id (Optional[int]): User who reactivated token
            
        Returns:
            bool: True if reactivation successful
        """
        if self.status != TokenStatus.SUSPENDED.value:
            return False
        
        if self.is_expired():
            return False  # Cannot reactivate expired token
        
        self.status = TokenStatus.ACTIVE.value
        self.revocation_reason = None
        self.revoked_by_user_id = None
        self.updated_at = datetime.now(timezone.utc)
        
        # Add reactivation metadata
        self.metadata['reactivation'] = {
            'timestamp': datetime.now(timezone.utc).isoformat(),
            'reactivated_by_user_id': reactivated_by_user_id
        }
        
        return True
    
    def get_family_tokens(self, include_revoked: bool = False) -> List['RefreshToken']:
        """
        Get all tokens in the same family for security analysis.
        
        Args:
            include_revoked (bool): Whether to include revoked tokens
            
        Returns:
            List[RefreshToken]: Tokens in the same family
        """
        query = RefreshToken.query.filter(RefreshToken.token_family == self.token_family)
        
        if not include_revoked:
            query = query.filter(RefreshToken.status.in_([
                TokenStatus.ACTIVE.value,
                TokenStatus.SUSPENDED.value
            ]))
        
        return query.order_by(RefreshToken.created_at).all()
    
    def get_family_size(self) -> int:
        """
        Get total number of tokens in family.
        
        Returns:
            int: Number of tokens in family
        """
        return RefreshToken.query.filter(RefreshToken.token_family == self.token_family).count()
    
    def get_rotation_chain(self) -> List['RefreshToken']:
        """
        Get full rotation chain for this token.
        
        Returns:
            List[RefreshToken]: Tokens in rotation chain
        """
        chain = []
        current_token = self
        
        # Follow chain to root
        while current_token.rotation_parent_id:
            parent = RefreshToken.query.get(current_token.rotation_parent_id)
            if not parent:
                break
            chain.insert(0, parent)
            current_token = parent
        
        # Add current token
        chain.append(self)
        
        # Add children
        children = self.rotation_children.order_by(RefreshToken.created_at).all()
        chain.extend(children)
        
        return chain
    
    def to_dict(self, include_sensitive: bool = False, include_metadata: bool = True) -> Dict[str, Any]:
        """
        Convert RefreshToken instance to dictionary representation.
        
        Args:
            include_sensitive (bool): Whether to include sensitive fields
            include_metadata (bool): Whether to include metadata
            
        Returns:
            Dict[str, Any]: Dictionary representation of RefreshToken
        """
        result = {
            'id': self.id,
            'user_id': self.user_id,
            'token_family': str(self.token_family),
            'status': self.status,
            'source': self.source,
            'expires_at': self.expires_at.isoformat() if self.expires_at else None,
            'last_used_at': self.last_used_at.isoformat() if self.last_used_at else None,
            'is_blacklisted': self.is_blacklisted,
            'security_score': self.security_score,
            'auth0_refresh_count': self.auth0_refresh_count,
            'suspicious_activity_count': self.suspicious_activity_count,
            'is_valid': self.is_valid(),
            'is_expired': self.is_expired(),
            'is_in_grace_period': self.is_in_grace_period(),
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None
        }
        
        if include_sensitive:
            result.update({
                'token_hash': self.token_hash,
                'auth0_token_id': self.auth0_token_id,
                'revoked_at': self.revoked_at.isoformat() if self.revoked_at else None,
                'revoked_by_user_id': self.revoked_by_user_id,
                'revocation_reason': self.revocation_reason,
                'rotation_parent_id': self.rotation_parent_id,
                'grace_period_expires': self.grace_period_expires.isoformat() if self.grace_period_expires else None
            })
        
        if include_metadata:
            result['metadata'] = self.metadata
        
        return result
    
    @classmethod
    def find_by_token_hash(cls, token_hash: str) -> Optional['RefreshToken']:
        """
        Find refresh token by token hash.
        
        Args:
            token_hash (str): SHA-256 hash of token to find
            
        Returns:
            Optional[RefreshToken]: Token instance if found
        """
        return cls.query.filter_by(token_hash=token_hash).first()
    
    @classmethod
    def find_by_token_value(cls, token_value: str) -> Optional['RefreshToken']:
        """
        Find refresh token by raw token value.
        
        Args:
            token_value (str): Raw token value to find
            
        Returns:
            Optional[RefreshToken]: Token instance if found
        """
        token_hash = cls._hash_token(token_value)
        return cls.find_by_token_hash(token_hash)
    
    @classmethod
    def find_active_by_user(cls, user_id: int) -> List['RefreshToken']:
        """
        Find all active refresh tokens for a user.
        
        Args:
            user_id (int): User ID to search for
            
        Returns:
            List[RefreshToken]: Active tokens for user
        """
        return cls.query.filter(
            cls.user_id == user_id,
            cls.status == TokenStatus.ACTIVE.value,
            cls.is_blacklisted == False,
            cls.expires_at > datetime.now(timezone.utc)
        ).order_by(cls.created_at.desc()).all()
    
    @classmethod
    def find_by_family(cls, token_family: Union[str, uuid.UUID]) -> List['RefreshToken']:
        """
        Find all tokens in a token family.
        
        Args:
            token_family (Union[str, UUID]): Token family identifier
            
        Returns:
            List[RefreshToken]: Tokens in family
        """
        if isinstance(token_family, str):
            token_family = uuid.UUID(token_family)
        
        return cls.query.filter(cls.token_family == token_family).order_by(cls.created_at).all()
    
    @classmethod
    def find_by_auth0_token_id(cls, auth0_token_id: str) -> Optional['RefreshToken']:
        """
        Find refresh token by Auth0 token identifier.
        
        Args:
            auth0_token_id (str): Auth0 token ID to search for
            
        Returns:
            Optional[RefreshToken]: Token instance if found
        """
        return cls.query.filter_by(auth0_token_id=auth0_token_id).first()
    
    @classmethod
    def cleanup_expired_tokens(cls, batch_size: int = 1000) -> int:
        """
        Clean up expired and revoked tokens in batches.
        
        Args:
            batch_size (int): Number of tokens to process per batch
            
        Returns:
            int: Number of tokens cleaned up
        """
        current_time = datetime.now(timezone.utc)
        cleanup_count = 0
        
        # Find expired tokens
        expired_tokens = cls.query.filter(
            cls.expires_at <= current_time,
            cls.status.in_([TokenStatus.ACTIVE.value, TokenStatus.SUSPENDED.value])
        ).limit(batch_size).all()
        
        for token in expired_tokens:
            token.status = TokenStatus.EXPIRED.value
            token.updated_at = current_time
            cleanup_count += 1
        
        # Find tokens past grace period
        grace_expired_tokens = cls.query.filter(
            cls.grace_period_expires <= current_time,
            cls.status == TokenStatus.ROTATED.value
        ).limit(batch_size).all()
        
        for token in grace_expired_tokens:
            token.grace_period_expires = None
            token.updated_at = current_time
            cleanup_count += 1
        
        if cleanup_count > 0:
            db.session.commit()
        
        return cleanup_count
    
    @classmethod
    def revoke_user_tokens(
        cls,
        user_id: int,
        reason: str,
        revoked_by_user_id: Optional[int] = None,
        exclude_token_id: Optional[int] = None
    ) -> int:
        """
        Revoke all active tokens for a user.
        
        Args:
            user_id (int): User whose tokens to revoke
            reason (str): Reason for mass revocation
            revoked_by_user_id (Optional[int]): User who initiated revocation
            exclude_token_id (Optional[int]): Token ID to exclude from revocation
            
        Returns:
            int: Number of tokens revoked
        """
        query = cls.query.filter(
            cls.user_id == user_id,
            cls.status.in_([TokenStatus.ACTIVE.value, TokenStatus.SUSPENDED.value])
        )
        
        if exclude_token_id:
            query = query.filter(cls.id != exclude_token_id)
        
        tokens = query.all()
        revoked_count = 0
        
        for token in tokens:
            if token.revoke_token(reason, revoked_by_user_id):
                revoked_count += 1
        
        if revoked_count > 0:
            db.session.commit()
        
        return revoked_count
    
    @classmethod
    def get_security_metrics(cls, user_id: Optional[int] = None) -> Dict[str, Any]:
        """
        Get security metrics for refresh tokens.
        
        Args:
            user_id (Optional[int]): User ID to filter metrics (all users if None)
            
        Returns:
            Dict[str, Any]: Security metrics and statistics
        """
        base_query = cls.query
        if user_id:
            base_query = base_query.filter(cls.user_id == user_id)
        
        metrics = {
            'total_tokens': base_query.count(),
            'active_tokens': base_query.filter(cls.status == TokenStatus.ACTIVE.value).count(),
            'expired_tokens': base_query.filter(cls.status == TokenStatus.EXPIRED.value).count(),
            'revoked_tokens': base_query.filter(cls.status == TokenStatus.REVOKED.value).count(),
            'blacklisted_tokens': base_query.filter(cls.is_blacklisted == True).count(),
            'suspicious_tokens': base_query.filter(cls.suspicious_activity_count > 0).count(),
            'low_security_score_tokens': base_query.filter(cls.security_score < 30).count(),
            'tokens_in_grace_period': base_query.filter(
                cls.grace_period_expires > datetime.now(timezone.utc)
            ).count()
        }
        
        # Calculate average security score
        avg_score = base_query.with_entities(func.avg(cls.security_score)).scalar()
        metrics['average_security_score'] = round(float(avg_score or 0), 2)
        
        # Count unique families
        unique_families = base_query.with_entities(cls.token_family).distinct().count()
        metrics['unique_token_families'] = unique_families
        
        return metrics
    
    def __repr__(self) -> str:
        """
        String representation of RefreshToken instance for debugging.
        
        Returns:
            str: String representation showing key token information
        """
        return (
            f"<RefreshToken(id={self.id}, user_id={self.user_id}, "
            f"status='{self.status}', family='{self.token_family}', "
            f"expires_at='{self.expires_at}', security_score={self.security_score})>"
        )
    
    def __str__(self) -> str:
        """
        Human-readable string representation of RefreshToken instance.
        
        Returns:
            str: User-friendly string representation
        """
        return f"RefreshToken {self.id} (User {self.user_id}, {self.status})"


# Database event listeners for additional functionality per Section 6.4.2.5
@event.listens_for(RefreshToken, 'before_insert')
def refresh_token_before_insert(mapper, connection, target):
    """
    Database event listener for RefreshToken creation audit logging.
    
    Args:
        mapper: SQLAlchemy mapper object
        connection: Database connection
        target: RefreshToken instance being inserted
    """
    # Set creation timestamp if not already set
    if not target.created_at:
        target.created_at = datetime.now(timezone.utc)
    
    # Set update timestamp
    target.updated_at = datetime.now(timezone.utc)


@event.listens_for(RefreshToken, 'before_update')
def refresh_token_before_update(mapper, connection, target):
    """
    Database event listener for RefreshToken update audit logging.
    
    Args:
        mapper: SQLAlchemy mapper object
        connection: Database connection
        target: RefreshToken instance being updated
    """
    # Always update the timestamp on modification
    target.updated_at = datetime.now(timezone.utc)


@event.listens_for(RefreshToken, 'after_insert')
def refresh_token_after_insert(mapper, connection, target):
    """
    Database event listener for RefreshToken creation security logging.
    
    Args:
        mapper: SQLAlchemy mapper object
        connection: Database connection
        target: RefreshToken instance that was inserted
    """
    # Log token creation for security monitoring
    # This would integrate with the authentication logging system
    pass


@event.listens_for(RefreshToken, 'after_update')
def refresh_token_after_update(mapper, connection, target):
    """
    Database event listener for RefreshToken update security logging.
    
    Args:
        mapper: SQLAlchemy mapper object
        connection: Database connection
        target: RefreshToken instance that was updated
    """
    # Log significant status changes for security monitoring
    if hasattr(target, '_sa_instance_state'):
        history = target._sa_instance_state.get_history('status', True)
        if history.has_changes():
            # Log status change for security audit
            pass


# Export the RefreshToken model and enums for use throughout the application
__all__ = ['RefreshToken', 'TokenStatus', 'TokenSource', 'TokenMetadata']