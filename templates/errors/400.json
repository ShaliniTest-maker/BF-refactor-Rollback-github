{# 
400 Bad Request Error Template for Flask Application
Purpose: Standardized JSON error responses for HTTP 400 request validation failures
Template Engine: Jinja2 3.1.2+ with Flask 3.1.1 integration
Validation: Marshmallow schema integration and Flask-Inputs validation per Section 4.3.1.1
API Compliance: Request validation error formatting per Section 4.3.2.2

Request Validation Error Context:
- Marshmallow schema validation error formatting with field-level details
- Flask-Inputs validation error context with parameter validation
- Schema alignment and validation framework integration requirements
- Input validation and response formatting per API contract preservation

Template Variables Expected:
- validation_errors: Dictionary of field-level validation errors
- marshmallow_errors: Marshmallow schema validation error details
- flask_inputs_errors: Flask-Inputs validation error context
- invalid_fields: List of fields that failed validation
- schema_name: Name of the validation schema that failed
- validation_method: Validation method used (marshmallow, flask_inputs, custom)
- request_data_errors: Issues with request data format or structure
- content_type_error: Content-Type header validation failure
- json_decode_error: JSON parsing error details
- required_fields: List of required fields that were missing
- field_constraints: Dictionary of field validation constraints
- parameter_errors: URL parameter validation errors
- query_string_errors: Query string parameter validation errors
- form_data_errors: Form data validation errors
- file_upload_errors: File upload validation errors
- data_type_errors: Data type conversion errors
- range_validation_errors: Value range validation failures
- format_validation_errors: Format validation failures (email, URL, etc.)
- custom_validation_errors: Custom business logic validation errors
#}
{%- extends "errors/base_error.json" -%}

{%- block error_type -%}ValidationError{%- endblock -%}

{%- block error_code -%}ERR_BAD_REQUEST{%- endblock -%}

{%- block error_message -%}
{%- if json_decode_error -%}
Bad Request. The request body contains invalid JSON: {{ json_decode_error }}
{%- elif content_type_error -%}
Bad Request. Invalid or missing Content-Type header. Expected 'application/json' but received '{{ request.headers.get('Content-Type', 'not provided') }}'.
{%- elif marshmallow_errors -%}
Bad Request. Request validation failed. The request data does not meet the required schema constraints.
{%- elif flask_inputs_errors -%}
Bad Request. Input parameter validation failed. One or more request parameters are invalid or missing.
{%- elif validation_errors -%}
Bad Request. Request validation failed. Please check the provided data and try again.
{%- elif required_fields -%}
Bad Request. Required fields are missing from the request: {{ required_fields | join(', ') }}.
{%- elif data_type_errors -%}
Bad Request. Data type validation failed. One or more fields have incorrect data types.
{%- elif parameter_errors -%}
Bad Request. URL parameter validation failed. Please check the parameter values and format.
{%- elif query_string_errors -%}
Bad Request. Query parameter validation failed. Invalid query string parameters provided.
{%- else -%}
Bad Request. The request could not be processed due to invalid or malformed data.
{%- endif -%}
{%- endblock -%}

{%- block error_details -%}
{
  "validation": {
    "validation_method": {{ validation_method | tojson if validation_method else "unknown" | tojson }},
    "schema_name": {{ schema_name | tojson if schema_name else null }},
    "total_errors": {{ validation_errors.keys() | list | length if validation_errors else 0 }},
    "validation_timestamp": "{{ moment().utc().isoformat() if moment else '' }}",
    "validation_context": {
      "request_content_type": {{ request.headers.get('Content-Type') | tojson if request.headers.get('Content-Type') else null }},
      "request_method": "{{ request.method or '' }}",
      "content_length": {{ request.headers.get('Content-Length') | int if request.headers.get('Content-Length') and request.headers.get('Content-Length').isdigit() else null }},
      "encoding": {{ request.encoding | tojson if request.encoding else null }}
    }
  },
  "field_errors": {
    {%- if marshmallow_errors -%}
    {%- for field_name, field_errors in marshmallow_errors.items() -%}
    "{{ field_name }}": {
      "errors": {{ field_errors | tojson }},
      "field_type": {{ marshmallow_field_types.get(field_name) | tojson if marshmallow_field_types and marshmallow_field_types.get(field_name) else null }},
      "required": {{ marshmallow_required_fields.get(field_name, false) | tojson if marshmallow_required_fields else false }},
      "constraints": {{ marshmallow_constraints.get(field_name) | tojson if marshmallow_constraints and marshmallow_constraints.get(field_name) else {} }},
      "provided_value": {{ request_data.get(field_name) | tojson if request_data and request_data.get(field_name) is defined else null }},
      "expected_format": {{ expected_formats.get(field_name) | tojson if expected_formats and expected_formats.get(field_name) else null }}
    }{%- if not loop.last -%},{%- endif -%}
    {%- endfor -%}
    {%- elif flask_inputs_errors -%}
    {%- for field_name, field_error in flask_inputs_errors.items() -%}
    "{{ field_name }}": {
      "errors": [{{ field_error | tojson }}],
      "input_type": {{ flask_input_types.get(field_name) | tojson if flask_input_types and flask_input_types.get(field_name) else null }},
      "required": {{ flask_required_fields.get(field_name, false) | tojson if flask_required_fields else false }},
      "provided_value": {{ request_data.get(field_name) | tojson if request_data and request_data.get(field_name) is defined else null }},
      "validation_rule": {{ flask_validation_rules.get(field_name) | tojson if flask_validation_rules and flask_validation_rules.get(field_name) else null }}
    }{%- if not loop.last -%},{%- endif -%}
    {%- endfor -%}
    {%- elif validation_errors -%}
    {%- for field_name, field_error in validation_errors.items() -%}
    "{{ field_name }}": {
      "errors": {{ field_error if field_error is iterable and field_error is not string else [field_error] | tojson }},
      "provided_value": {{ request_data.get(field_name) | tojson if request_data and request_data.get(field_name) is defined else null }},
      "field_path": {{ field_paths.get(field_name) | tojson if field_paths and field_paths.get(field_name) else field_name | tojson }}
    }{%- if not loop.last -%},{%- endif -%}
    {%- endfor -%}
    {%- endif -%}
  },
  "request_analysis": {
    "json_parsing": {
      "valid": {{ (not json_decode_error) | tojson }},
      "error": {{ json_decode_error | tojson if json_decode_error else null }},
      "encoding_detected": {{ request.encoding | tojson if request.encoding else "utf-8" | tojson }},
      "content_length": {{ request.headers.get('Content-Length') | int if request.headers.get('Content-Length') and request.headers.get('Content-Length').isdigit() else null }}
    },
    "content_type": {
      "provided": {{ request.headers.get('Content-Type') | tojson if request.headers.get('Content-Type') else null }},
      "expected": {{ expected_content_type | tojson if expected_content_type else "application/json" | tojson }},
      "valid": {{ (not content_type_error) | tojson }},
      "charset": {{ request.charset | tojson if request.charset else null }}
    },
    "data_structure": {
      "request_data_type": {{ request_data_type | tojson if request_data_type else (request.get_json().__class__.__name__ if request.get_json() else "None") | tojson }},
      "expected_structure": {{ expected_structure | tojson if expected_structure else "object" | tojson }},
      "provided_keys": {{ request.get_json().keys() | list | tojson if request.get_json() and hasattr(request.get_json(), 'keys') else [] }},
      "missing_required_keys": {{ required_fields | tojson if required_fields else [] }},
      "unexpected_keys": {{ unexpected_fields | tojson if unexpected_fields else [] }}
    }
  },
  "parameter_errors": {
    "url_parameters": {{ parameter_errors | tojson if parameter_errors else {} }},
    "query_string": {{ query_string_errors | tojson if query_string_errors else {} }},
    "form_data": {{ form_data_errors | tojson if form_data_errors else {} }},
    "file_uploads": {{ file_upload_errors | tojson if file_upload_errors else {} }},
    "headers": {{ header_validation_errors | tojson if header_validation_errors else {} }}
  },
  "data_type_validation": {
    "type_errors": {{ data_type_errors | tojson if data_type_errors else {} }},
    "format_errors": {{ format_validation_errors | tojson if format_validation_errors else {} }},
    "range_errors": {{ range_validation_errors | tojson if range_validation_errors else {} }},
    "pattern_errors": {{ pattern_validation_errors | tojson if pattern_validation_errors else {} }},
    "enum_errors": {{ enum_validation_errors | tojson if enum_validation_errors else {} }}
  },
  "marshmallow_context": {
    "schema_class": {{ marshmallow_schema_class | tojson if marshmallow_schema_class else null }},
    "schema_version": {{ marshmallow_schema_version | tojson if marshmallow_schema_version else null }},
    "partial_validation": {{ marshmallow_partial | tojson if marshmallow_partial is defined else false }},
    "unknown_fields_handling": {{ marshmallow_unknown | tojson if marshmallow_unknown else "RAISE" | tojson }},
    "nested_errors": {{ marshmallow_nested_errors | tojson if marshmallow_nested_errors else {} }},
    "field_names": {{ marshmallow_field_names | tojson if marshmallow_field_names else [] }},
    "dump_errors": {{ marshmallow_dump_errors | tojson if marshmallow_dump_errors else {} }},
    "load_errors": {{ marshmallow_load_errors | tojson if marshmallow_load_errors else {} }}
  },
  "flask_inputs_context": {
    "input_module": {{ flask_inputs_module | tojson if flask_inputs_module else "flask_inputs" | tojson }},
    "input_types_used": {{ flask_input_types_used | tojson if flask_input_types_used else [] }},
    "url_validation": {{ flask_url_validation_errors | tojson if flask_url_validation_errors else {} }},
    "json_validation": {{ flask_json_validation_errors | tojson if flask_json_validation_errors else {} }},
    "args_validation": {{ flask_args_validation_errors | tojson if flask_args_validation_errors else {} }},
    "headers_validation": {{ flask_headers_validation_errors | tojson if flask_headers_validation_errors else {} }}
  },
  "business_logic_validation": {
    "custom_validators": {{ custom_validators_used | tojson if custom_validators_used else [] }},
    "business_rules": {{ business_rule_violations | tojson if business_rule_violations else {} }},
    "cross_field_validation": {{ cross_field_errors | tojson if cross_field_errors else {} }},
    "database_constraints": {{ database_constraint_errors | tojson if database_constraint_errors else {} }},
    "unique_constraints": {{ unique_constraint_errors | tojson if unique_constraint_errors else {} }}
  },
  "client_guidance": {
    "corrective_actions": [
      {%- if json_decode_error -%}
      "Ensure request body contains valid JSON format",
      "Check for syntax errors, trailing commas, or unescaped characters",
      "Verify encoding is UTF-8 and Content-Type is application/json"
      {%- elif content_type_error -%}
      "Set Content-Type header to 'application/json'",
      "Ensure request body is properly formatted JSON",
      "Include charset=utf-8 in Content-Type if needed"
      {%- elif required_fields -%}
      "Include all required fields: {{ required_fields | join(', ') }}",
      "Verify field names match the expected schema exactly",
      "Ensure required fields are not null or empty"
      {%- elif validation_errors -%}
      "Review field validation requirements and constraints",
      "Ensure data types match expected formats",
      "Check for required fields and proper value ranges"
      {%- else -%}
      "Review the API documentation for correct request format",
      "Validate request data against the expected schema",
      "Ensure all required parameters are provided"
      {%- endif -%}
    ],
    "validation_requirements": {
      "required_fields": {{ required_fields | tojson if required_fields else [] }},
      "optional_fields": {{ optional_fields | tojson if optional_fields else [] }},
      "field_formats": {{ field_format_requirements | tojson if field_format_requirements else {} }},
      "data_types": {{ expected_data_types | tojson if expected_data_types else {} }},
      "value_ranges": {{ value_range_requirements | tojson if value_range_requirements else {} }},
      "pattern_requirements": {{ pattern_requirements | tojson if pattern_requirements else {} }}
    },
    "example_valid_request": {
      "url": {{ example_request_url | tojson if example_request_url else (request.base_url if request.base_url else "/api/example") | tojson }},
      "method": "{{ request.method or 'POST' }}",
      "headers": {
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      "body": {{ example_request_body | tojson if example_request_body else {} }}
    }
  },
  "validation_summary": {
    "total_fields_validated": {{ total_fields_validated or 0 }},
    "fields_passed": {{ fields_passed_count or 0 }},
    "fields_failed": {{ fields_failed_count or 0 }},
    "validation_duration_ms": {{ validation_duration_ms if validation_duration_ms else null }},
    "schema_validation_enabled": {{ schema_validation_enabled | tojson if schema_validation_enabled is defined else true }},
    "strict_validation_mode": {{ strict_validation_mode | tojson if strict_validation_mode is defined else false }},
    "validation_warnings": {{ validation_warnings | tojson if validation_warnings else [] }}
  }
}
{%- endblock -%}

{%- block api_version -%}1.0{%- endblock -%}

{%- block support_contact -%}support@company.com{%- endblock -%}

{%- block documentation_url -%}https://docs.company.com/api/errors/400-bad-request{%- endblock -%}

{%- block help_text -%}
{%- if json_decode_error -%}
Your request contains invalid JSON. Please ensure your request body is properly formatted JSON and try again.
{%- elif content_type_error -%}
Your request is missing the required Content-Type header. Please set Content-Type to 'application/json' and try again.
{%- elif required_fields -%}
Your request is missing required fields: {{ required_fields | join(', ') }}. Please include all required fields and try again.
{%- elif validation_errors -%}
Your request contains validation errors. Please review the field errors above, correct the issues, and try again.
{%- elif data_type_errors -%}
Your request contains fields with incorrect data types. Please ensure all fields match the expected data types and try again.
{%- else -%}
Your request could not be processed due to validation errors. Please review the error details above and correct the issues before retrying.
{%- endif -%}
{%- endblock -%}

{%- if config.DEBUG -%}
{%- block debug_variables -%}
{
  "validation_debug": {
    "original_request_data": {{ original_request_data | tojson if original_request_data else null }},
    "processed_request_data": {{ processed_request_data | tojson if processed_request_data else null }},
    "validation_stack_trace": {{ validation_stack_trace | tojson if validation_stack_trace else null }},
    "marshmallow_schema_dump": {{ marshmallow_schema_debug | tojson if marshmallow_schema_debug else null }},
    "flask_inputs_debug": {{ flask_inputs_debug_info | tojson if flask_inputs_debug_info else null }},
    "custom_validator_debug": {{ custom_validator_debug | tojson if custom_validator_debug else null }}
  },
  "request_context_debug": {
    "request_args": {{ dict(request.args) | tojson if request.args else {} }},
    "request_form": {{ dict(request.form) | tojson if request.form else {} }},
    "request_files": {{ request.files.keys() | list | tojson if request.files else [] }},
    "request_json_safe": {{ request.get_json(silent=True) | tojson if request.get_json(silent=True) else null }},
    "request_headers_filtered": {
      "content-type": "{{ request.headers.get('Content-Type', 'Not provided') }}",
      "content-length": "{{ request.headers.get('Content-Length', 'Not provided') }}",
      "accept": "{{ request.headers.get('Accept', 'Not provided') }}",
      "user-agent": "{{ request.headers.get('User-Agent', 'Not provided') | truncate(100) }}"
    }
  },
  "validation_framework_debug": {
    "marshmallow_version": "{{ marshmallow_version if marshmallow_version else 'not detected' }}",
    "flask_inputs_available": {{ flask_inputs_available | tojson if flask_inputs_available is defined else false }},
    "wtforms_available": {{ wtforms_available | tojson if wtforms_available is defined else false }},
    "cerberus_available": {{ cerberus_available | tojson if cerberus_available is defined else false }},
    "validation_libraries_loaded": {{ validation_libraries | tojson if validation_libraries else [] }}
  },
  "performance_debug": {
    "validation_timing": {
      "total_validation_time_ms": {{ total_validation_time_ms if total_validation_time_ms else null }},
      "json_parsing_time_ms": {{ json_parsing_time_ms if json_parsing_time_ms else null }},
      "schema_validation_time_ms": {{ schema_validation_time_ms if schema_validation_time_ms else null }},
      "business_logic_validation_time_ms": {{ business_logic_validation_time_ms if business_logic_validation_time_ms else null }}
    },
    "memory_usage": {
      "validation_memory_mb": {{ validation_memory_mb if validation_memory_mb else null }},
      "peak_memory_mb": {{ peak_memory_mb if peak_memory_mb else null }}
    }
  },
  "blueprint_context": {
    "blueprint_name": "{{ request.blueprint or 'main' }}",
    "endpoint": "{{ request.endpoint or 'unknown' }}",
    "view_function": "{{ request.url_rule.endpoint if request.url_rule else 'unknown' }}",
    "url_rule": "{{ request.url_rule.rule if request.url_rule else 'unknown' }}",
    "methods_allowed": {{ request.url_rule.methods | list | tojson if request.url_rule and request.url_rule.methods else [] }}
  }
}
{%- endblock -%}

{%- block debug_request_data -%}
{
  "raw_request_data": {
    "method": "{{ request.method }}",
    "url": "{{ request.url }}",
    "base_url": "{{ request.base_url }}",
    "path": "{{ request.path }}",
    "query_string": "{{ request.query_string.decode() if request.query_string else '' }}",
    "content_type": "{{ request.content_type or 'not provided' }}",
    "content_length": {{ request.content_length if request.content_length else null }},
    "mimetype": "{{ request.mimetype or 'not provided' }}",
    "charset": "{{ request.charset or 'not provided' }}"
  },
  "request_data_analysis": {
    "has_json": {{ request.is_json | tojson }},
    "json_parsing_success": {{ (request.get_json(silent=True) is not none) | tojson }},
    "content_encoding": "{{ request.headers.get('Content-Encoding', 'not provided') }}",
    "transfer_encoding": "{{ request.headers.get('Transfer-Encoding', 'not provided') }}",
    "expect_header": "{{ request.headers.get('Expect', 'not provided') }}"
  },
  "validation_config": {
    "strict_mode": {{ validation_config.get('strict_mode', false) | tojson if validation_config else false }},
    "ignore_unknown_fields": {{ validation_config.get('ignore_unknown_fields', false) | tojson if validation_config else false }},
    "case_sensitive": {{ validation_config.get('case_sensitive', true) | tojson if validation_config else true }},
    "trim_whitespace": {{ validation_config.get('trim_whitespace', true) | tojson if validation_config else true }},
    "convert_types": {{ validation_config.get('convert_types', true) | tojson if validation_config else true }}
  },
  "environment_debug": {
    "flask_env": "{{ config.ENV or 'unknown' }}",
    "debug_mode": {{ config.DEBUG | tojson }},
    "testing_mode": {{ config.TESTING | tojson if config.TESTING is defined else false }},
    "marshmallow_env": "{{ marshmallow_env if marshmallow_env else 'not detected' }}",
    "validation_middleware_active": {{ validation_middleware_active | tojson if validation_middleware_active is defined else false }}
  }
}
{%- endblock -%}
{%- endif -%}

{# 
Bad Request Error Template Documentation:

Purpose:
This template provides standardized 400 Bad Request error responses with comprehensive
request validation failure context, supporting Marshmallow schema validation, Flask-Inputs
parameter validation, and custom business logic validation as specified in Section 4.3.

Key Features:
1. Marshmallow Schema Integration:
   - Comprehensive Marshmallow schema validation error formatting per Section 4.3.1.1
   - Field-level error details with validation constraint information
   - Schema class context and validation metadata
   - Nested validation error handling and unknown field management
   - Partial validation support and custom field validation

2. Flask-Inputs Validation:
   - Flask-Inputs parameter validation error formatting per Section 4.3.1.1
   - URL parameter, query string, and form data validation
   - Input type validation with constraint details
   - Request header and file upload validation support
   - Integration with Flask request context for comprehensive validation

3. Request Analysis and Parsing:
   - JSON parsing error detection and detailed error context
   - Content-Type header validation and charset detection
   - Request data structure analysis and format validation
   - Data type conversion error handling and reporting
   - Request encoding and content length validation

4. Client Guidance and Correction:
   - Actionable error messages with specific correction guidance
   - Example valid request format with proper structure
   - Field requirement documentation and constraint details
   - Validation rule explanation and format requirements
   - API documentation links for detailed schema information

Template Usage in Flask Blueprints:

from marshmallow import Schema, fields, ValidationError
from flask_inputs import Inputs
from flask import render_template, request

# Marshmallow Schema Example
class UserCreateSchema(Schema):
    username = fields.Str(required=True, validate=Length(min=3, max=50))
    email = fields.Email(required=True)
    age = fields.Int(required=True, validate=Range(min=18, max=120))
    bio = fields.Str(missing='', validate=Length(max=500))

@blueprint.route('/users', methods=['POST'])
def create_user():
    schema = UserCreateSchema()
    try:
        validated_data = schema.load(request.get_json())
        return create_user_service(validated_data)
    except ValidationError as e:
        return render_template('errors/400.json',
            validation_method='marshmallow',
            schema_name='UserCreateSchema',
            marshmallow_errors=e.messages,
            marshmallow_field_types=schema.fields,
            marshmallow_required_fields={k: f.required for k, f in schema.fields.items()},
            request_data=request.get_json()
        ), 400

# Flask-Inputs Example
class UserSearchInputs(Inputs):
    json = [
        Str('query', required=True),
        Int('page', default=1),
        Int('per_page', default=20, validate=lambda x: 1 <= x <= 100)
    ]
    args = [
        Str('sort_by', default='created_at'),
        Str('order', default='desc', validate=lambda x: x in ['asc', 'desc'])
    ]

@blueprint.route('/users/search', methods=['GET', 'POST'])
def search_users():
    inputs = UserSearchInputs(request)
    if not inputs.validate():
        return render_template('errors/400.json',
            validation_method='flask_inputs',
            flask_inputs_errors=inputs.errors,
            flask_input_types={'query': 'str', 'page': 'int', 'per_page': 'int'},
            flask_required_fields={'query': True, 'page': False, 'per_page': False},
            request_data=request.get_json()
        ), 400
    
    return search_users_service(inputs.json, inputs.args)

# JSON Parsing Error Handling
@blueprint.errorhandler(400)
def handle_bad_request(error):
    # Detect JSON parsing errors
    if hasattr(error, 'original_exception'):
        if isinstance(error.original_exception, ValueError):
            return render_template('errors/400.json',
                json_decode_error=str(error.original_exception),
                validation_method='json_parsing'
            ), 400
    
    # Content-Type validation
    if request.content_type != 'application/json':
        return render_template('errors/400.json',
            content_type_error=True,
            expected_content_type='application/json',
            validation_method='content_type'
        ), 400
    
    # Generic bad request
    return render_template('errors/400.json',
        validation_errors={'general': ['Invalid request format or data']},
        validation_method='generic'
    ), 400

# Custom Business Logic Validation
@blueprint.route('/users/<int:user_id>/profile', methods=['PUT'])
def update_user_profile(user_id):
    try:
        # Schema validation first
        schema = UserProfileSchema()
        data = schema.load(request.get_json())
        
        # Business logic validation
        business_errors = {}
        if data.get('username'):
            if username_exists(data['username'], exclude_user_id=user_id):
                business_errors['username'] = ['Username already exists']
        
        if data.get('email'):
            if email_exists(data['email'], exclude_user_id=user_id):
                business_errors['email'] = ['Email address already in use']
        
        if business_errors:
            return render_template('errors/400.json',
                validation_method='business_logic',
                validation_errors=business_errors,
                business_rule_violations=business_errors,
                schema_name='UserProfileSchema'
            ), 400
        
        return update_user_profile_service(user_id, data)
        
    except ValidationError as e:
        return render_template('errors/400.json',
            validation_method='marshmallow',
            schema_name='UserProfileSchema',
            marshmallow_errors=e.messages,
            request_data=request.get_json()
        ), 400

Request Validation Framework Integration:
- Seamless integration with Marshmallow 3.x for complex schema validation
- Flask-Inputs support for simple parameter validation and type conversion
- Custom validation function support for business logic validation
- Multi-layer validation with schema, business rules, and database constraints
- Comprehensive error context preservation throughout validation pipeline

Input Validation Coverage:
- JSON request body parsing and structure validation
- Query parameter validation with type conversion and constraints
- Form data validation including file uploads and multipart data
- HTTP header validation for required and formatted headers
- URL parameter validation with routing constraint integration

Data Type and Format Validation:
- Primitive type validation (string, integer, float, boolean)
- Complex type validation (arrays, objects, nested structures)
- Format validation (email, URL, date, time, UUID, regex patterns)
- Range and length validation for numeric and string fields
- Custom validation rules and business-specific constraints

Error Response Standardization:
- Consistent error structure across all validation methods per Section 4.3.1.4
- Field-level error granularity with specific constraint violation details
- Client-friendly error messages with actionable guidance
- Comprehensive validation context for debugging and troubleshooting
- Template inheritance ensuring consistent API contract compliance

Security and Performance Considerations:
- Validation error context filtering to prevent information disclosure
- Request data sanitization in debug mode to protect sensitive information
- Performance monitoring for validation operations with timing metrics
- Memory usage tracking for large request validation operations
- Integration with security monitoring for validation failure patterns

API Contract Preservation:
- Maintains identical error response structure from Node.js implementation
- JSON response formatting compatible with existing client applications
- HTTP status code preservation with enhanced validation context
- Template inheritance ensuring consistent error handling patterns
- Backward compatibility with existing API error handling expectations

Multi-Validation Method Support:
- Marshmallow schema validation for complex data structures
- Flask-Inputs validation for simple parameter validation
- Custom validation functions for business logic constraints
- Database constraint validation with detailed error context
- Cross-field validation support for related field dependencies

This template ensures comprehensive request validation error handling while maintaining
security best practices and providing detailed context for client-side error handling
and API debugging across the Flask application architecture per Section 4.3.1.4.
#}